## HTTP

HTTP는 응용계층의 프로토콜로 `요청-응답 기반의 프로토콜이자`, `미디어 독립적`이고 `Stateless`하며 `지속연결기능`을 제공하는 프로토콜이다.

`요청-응답 기반`이라는것은 서버-클라이언트 구조에서 클라이언트의 요청별로 서로다른 응답을 얻는것

`미디어 독립적`이라는것은 HTTP에서의 자원의 제한을 두지않고 다양한 미디어타입(MIME Type)의 자원을 주고받을 수 있는것

`Stateless`라는것은 서버에서 클라이언트별로 상태를 저장해두지 않는것으로, 기존의 TCP 서버자원 하나를 클라이언트가 독점하여 연결상태를 유지하였다면

HTTP에서는 요청이후 응답할때 연결을 끊음으로서 독점하지않고 이로인해 `특정서버에 종속적이지 않게 되고, 편하게 확장할 수 있게 된다.`

또한 편리한 확장성으로 인해, `문제발생시 다른 서버로 요청을 옮기는것에 큰 부담이 없어서 견고성도 가지게된다.`

즉, `Stateless`는 서버가 클라이언트 상태에 관심을 두지않음으로서 `확장성`과 `견고성`을 얻게 된다.

`지속연결기능`은 HTTP 1.0 이하에서는 해당되는 말은 아니지만, 1.1 이후로부터 `keep-alive`와 같이 매 요청마다 연결-해제를 하는것이 아닌, 일부시간동안 연결을 유지하는 기능을 제공한다.

### HTTP Method

POST 메소드의 경우 HTTP Header에 Location 필드를 통해 새로만들어진 자원의 경로를 표기 할 수 있다.

PUT과 PATCH의 주요한 차이점은 전자의 경우 요청본문을 덮어씌우고, 후자의 경우엔 요청된 데이터만 변경하는 차이가 있다.

### HTTP 상태코드: 300 번대

300번대 코드가 주로 리다이렉션 목적으로 사용된다.

여기서 리다이렉션은 새롭게 방향을 바꾼다는것으로, 

클라이언트가 해당 응답코드를 받는순간 곧바로 Location 헤더에 해당하는 경로로 재요청을 하게된다.

여기서 리다이렉션에는 크게 `영구적 리다이렉션`과 `임시 리다이렉션`으로 나뉜다.

영구 리다이렉션은 영구적으로 자원의 위치가 변경되었음을 의미하므로, 변경된 URL을 기억하면 된다.

HTTP Status Code로는 주로 `301`, `308`이며, 둘 차이는 `클라이언트의 재요청 메소드 변경여부`에 달려있다.

`308`의 경우 `재요청 메소드가 바뀌지 않는다.`

```
GET / POST 요청을 보냈더니 301을 받았다면

클라이언트의 재요청 메소드의 종류는 GET으로 바뀔 수 있다.

하지만 GET / POST 요청을 보냈을 때 308을 받았다면

클라이언트의 재요청 메소드의 종류는 바뀌지 않고 GET / POST 그대로 따라간다.
```

그밖의 일반적인 리다이렉트 목적으로 사용되는 것을 `임시 리다이렉션` 이며

HTTP Status Code로는 주로 `302`, `303`, `307`을 사용한다. 이들 역시 재요청 메소드 변경여부에 따라 분류된다.

`302`는 `301`과 마찬가지로 POST요청을 처음에 보냈더라도 재요청때에는 변경될 수 있다.

`303`은 무조건 GET으로 변경되고, `307`은 `308`과 동일하게 재요청때 변경되는것 없이 따라간다.

### HTTP/1.1

1.0까지는 요청에 따라 응답하는데 있어서 매 순간 연결-해제 오버헤드가 발생하는것을 확인하여 연결을 지속적으로 열어둠으로서 구현하였다. 이를 <a href="https://www.rfc-editor.org/rfc/rfc2616.html#section-8.1">`지속적인 연결`</a>이라고 부른다.

하나의 요청에 대한 응답이 오기까지 무조건 대기하던것을 대기하지않고 보낼 수 있도록 하여 지연시간을 단축하였다. 이를 <a href="https://www.rfc-editor.org/rfc/rfc2616.html#section-8.1.2.2">`파이프라이닝`</a> 이라고 부른다.

### HTTP/2

기존의 HTTP/1.1은 파이프라이닝 기법을 통해 연결-해제의 오버헤드를 획기적으로 줄였지만

파이프 라이닝은 요청온 순서대로 처리를 해서 응답도 순서를 맞춰야 하는 특징이 있다.

여기서 먼저 도착한 패킷에 처리가 상당히 오래걸린다면 뒤에 대기하고 있는 패킷들도 함께 그만큼 대기해야 하는 문제를 HOL(`Head-Of-Line blocking`) 이라고 한다.

이와같은 문제를 HTTP/2.0에서는 `멀티 플렉싱`이라는 기술을 도입하여 해결한다.

- 멀티플렉싱이란 스트림을 이용해서 병렬적으로 메세지를 주고받는 기술

추가적으로 송 수신 효율을 높이기 `헤더 압축`과 더이상 텍스트 메세지가 아닌 `바이너리 데이터`기반의 메세지를 송 수신한다.

마지막으로 클라이언트가 미래에 필요할 것으로 예상되는 자원을 서버에서 미리 전송하는 `서버푸시` 기능을 제공한다.

- 이는 1.1까지는 리소스 인라인으로서 흔히 인라인 형태 HTML로 구현된 경우 클라이언트에 필요한 리소스를 함께 제공함. 하지만 2 부터는 서버푸시 기능으로 <a href="https://blog.bespinglobal.com/post/http1-1-http2/">서버푸시</a> 미리 얻어올 수 있음

### HTTP/3

기존의 TCP를 사용하지 않고 `UDP를 기반`으로 구현된 `QUIC`(Quick UDP Internet Connections) 프로토콜 기반으로 동작한다.

QUIC는 HTTP/2와 동일하게 스트림 기반 멀티플렉싱을 제공한다.

<a href="https://evan-moon.github.io/2019/10/08/what-is-http3/#http3%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%86%8C%EA%B0%9C">QUIC에 대한 글</a>
