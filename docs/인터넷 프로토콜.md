## 네트워크 계층의 필요성

기존의 물리 계층과 데이터링크 계층까지만 해도 `같은 네트워크` 상에 송 수신지를 결정할 수 있는 MAC 주소와 함께라면 충분히 통신이 가능하다. 

그리고 이는 어디까지나 "같은 네트워크"라는 제약조건이 있는것이고, 즉 `같은 LAN`이라는 영역내에서는 충분히 가능하다.

하지만 통신이랄게 `다른 네트워크에 있는 호스트와 통신`이 발생할 수 있기에, 이를 만족시켜주는 계층이 `네트워크 계층`이다.

왜냐하면 MAC주소는 어디까지나 `NIC(Network Interface Card)`에 의해 대부분 일정한 물리적 주소를 가지는 것이며 

이는 수신자를 특정지을 순 있어도, 수신자가 속한 수신지를 특정짓거나 수신지까지의 경로를 파악할 수는 없기 때문이다.

그래서 네트워크 계층에서는 `라우터`라는 장비를 통해 수신지까지의 최적경로를 찾게 되고,

수신지에 대한 주소는 는 네트워크 계층에서 `IP(Internet Protocol) 주소`로서 사용한다.

만약 수신지의 IP주소만 알고있는 경우에 MAC주소를 몰라서 수신지 내 수신자를 특정지을 수 없게되는데, 이 때 사용하는것이 `ARP(Address Resolution Protocol)`이다.

## IP (Internet Protocol)

IP의 가장 큰 기능은 `IP 주소지정`, `IP 단편화`가 있다.

`IP 주소지정`은 IP 주소를 가지고 송 수신 대상을 지정하는것을 의미하고

`IP 단편화는` 전송하고자 하는 패킷의 크기가 `MTU`보다 크다면, 쪼개어 전송하는 기능을 뜻한다.

여기서 말하는 `MTU(Maximum Transmission Unit)`은 최대 전송가능한 IP 패킷 크기를 의미한다.

여기서 유의할 점은 `MTU`에는 `IP패킷 헤더`를 포함한 1500바이트임을 잊으면 안된다.

### IPv4 헤더

IPv4의 헤더는 상당히 복잡한데, 핵심은 다음과 같다.

- `식별자`: 패킷에 할당된 번호로서, 만약 쪼개어진 패킷이라면 `원본 메세지의 식별번호`가 담겨있다.

- `플래그`: 총 세개의 비트로서, 첫 비트는 무시하고 두번째 비트는 `DF(Don't Fragment)`로서 쪼개도 되는지 여부를 나타내고, 세번째 비트는 `MF(More Fragment)`로서 0이면 마지막 패킷, 1이면 더와야함을 의미한다.

- `단편화 오프셋`: 모든 패킷이 순서대로 도달하진 않기 때문에, `원본 메세지에서 몇번째로 떨어진 조각인지`를 나타낸다. 그래야 수신지에서 재조합이 가능하다.

- `TTL`: Time To Live의 약자로서 라우터를 거칠때 마다 TTL이 1씩 감소하고 다 감소한 패킷의 경우 `ICMP 프로토콜`을 통해 송신자에게 시간초과 메세지를 보낸다.

- `프로토콜`: `상위 네트워크 계층의 프로토콜이 무엇`인지 나타낸다.

여기서 식별자(어디서 부터 쪼개졋는지), 플래그(더 쪼개짐 가능?, 이제 마지막임?), 단편화 오프셋(얘는 몇번째 조각이더라) -> `IP 단편화 기능`을 위해

`송신지 주소 수신지 주소` -> IP 주소지정 기능을 위해 존재한다.

### IPv6 헤더

`IPv6`는 4바이트의 크기를 가지며 10진수 4개로 구성된 `IPv4`와는 달리 `16바이트` 크기에 `16진수` `8개`로 구성되어있다.

- `다음 헤더`: 상위 계층의 프로토콜을 가리키거나 확장헤더를 가리킨다. IPv6는 `기본헤더`에 필요하다면 확장헤더를 더할 수 있다.

- `홉 제한`: IPv4의 TTL이라고 생각하면 된다.


재미있는건 IPv6의 크기는 언제나 고정이지만 `IPv4`는 옵션과 패딩필드에 의해 `가변적`이라는 차이가 존재한다.

## ARP (Address Resolution Protocol)

ARP는 **같은 네트워크 내에 IP주소를 통해 MAC 주소를 얻는 방법**을 의미한다.

여기서 분명 네트워크 계층은 `서로다른 네트워크` 사이에서의 통신을 가능케 하는 목적을 가진다고 했는데 ARP로 달성하는 방법이 뭘까?

ARP는 `ARP 패킷`을 가지며, ARP 패킷의 헤더는 다음과 같이 단순하다.

- OPCode: 요청인지 응답인지여부

- 송신지 하드웨어 주소: 송신자 MAC주소

- 송신지 프로토콜 주소: 송신지 IP주소

- 수신지 하드웨어 주소: 수신자 MAC주소

- 수신지 프로토콜 주소: 수신지 IP주소

즉, ARP 패킷은 서로의 주소에 관한 네트워크 계층까지의 정보(MAC, IP)를 주고받을려는 목적의 패킷이다.

그리고 ARP의 동작과정을 살펴보면 이해가 된다.

### ARP 기본 동작과정

같은 네트워크의 범위는 결국 하나의 LAN 이라는 의미가 되고, LAN을 이더넷으로 구현하였다면

같은 이더넷 스위치에 속하는 호스트들을 의미한다.

여기서 스위치 자체도 호스트라고 볼 수 있다는점을 주의해야 한다.

크게 동작과정은 

1. ARP 요청

2. ARP 응답

3. `ARP 테이블` 갱신 

으로 나뉘어져 있다.

`요청`은 해당 네트워크 내에 `브로드케스트`로 "제 IP가 이렇고 MAC은 이런데 xxx.xxx.xxx.xxx IP주소는 누굽니까?" 하고 ARP 패킷을 보내는 행동이다.

그러면 `응답`을 하는 호스트가 "그놈이 저입니다. 저의 IP가 이렇고 MAC은 이렇습니다." 하고서 요청을 보낸 `IP주소`와 `MAC주소`를 알기에 응답을 `유니케스트`로 보낸다.

그러면 각각의 호스트들은 "아 IP xxx.xxx.xxx.xxx 는 이런 MAC 주소구나" 하고 자신의 `ARP`테이블에 기록한다.

### ARP 동작과정: 서로다른 네트워크

물론 이걸 더 나아가서 서로다른 네트워크에 속한 호스트끼리의 통신이라고 했을 때에도 동일하게 작동한다.

기본적으로 통신을위한 동작과정은 다음과 같을것이다.

일단 본인과 같은 라우터에 속해있는지 검사를 할것이고, 이게 아니라면 송신자가 속한 라우터로 패킷을 전달할 것이다.

만약 A가 아무것도 모르는 상태 즉, 본인의 ARP테이블에 해당 라우터1의 MAC주소가 없고 IP만 있다면 여기서 ARP 요청, 응답, 갱신 이뤄진다.

그다음 라우터1은 자신의 라우팅 테이블을 통해 현재 라우터2로 이동해야 함을 알게 되고

라우팅 테이블에는 라우터2의 IP주소만을 알고있는데, IP주소를 통해 ARP 테이블 조회를 해보니까 MAC주소를 모른다

이런 상황에서도 라우터1과 2사이에 ARP가 요청, 응답, 갱신이 이뤄진다.

그렇게 무사히 라우터2에 도착해서 B호스트가 라우터2안에 있으니까 전달하려 하는데 

B호스트의 IP주소만을 알고있는 라우터2는 MAC주소를 얻기위해 또 ARP 요청, 응답, 갱신이 이뤄진다.

### IP 단편화를 피하는법

사실 IP단편화는 이뤄지지 않는편이 좋다. 

왜냐하면 쪼개어진단것 자체가 둘 사이에 많은 패킷 이동이 이뤄져야함을 의미하고, 즉 트래픽 증가와 대역폭 낭비로 이어진다.

한편으로는 A와 B사이 통신에서 A와 B의 MTU는 해당 패킷을 단편화 하지 않아도 되는데, 중간에 이어지는 라우터가 단편화를 해야하는 경우가 있다.

이러한 상황을 막아야 단편화를 최소화 할 수 있기에, 경로상의 최적의 MTU를 `경로 MTU`라 부른다.

그래서 오늘날 IP패킷을 살펴보면 대부분 헤더속 플래그필드의 `DF`비트가 켜져있다.















