## 전송계층의 대표적인 프로토콜

<a href="http://www.ktword.co.kr/test/view/view.php?no=361">한국 정보통신기술 용어 TCPz`</a>

전송계층은 IP 패킷과 달리 신뢰성과 연결지향적임을 특징으로 가지고 있다.

위 두가지 특징을 모두 갖고있는 프로토콜이 `TCP` 이다. `UDP`는 별도의 연결과정도 없고 비연결형의 프로토콜이다.

## TCP 

TCP는 크게 `연결 수립` -> `데이터 송수신` -> `연결 종료` 단계로 나눠져 있다.

여기서 `데이터 송수신` 단계에서의 주요 기능은 `흐름제어`, `오류제어`, `혼잡제어` 등이 있다.

TCP의 PDU는 세그먼트인데 여기서 `TCP헤더 부분을 제외`한 순수 페이로드의 양을 `MSS(Maximum Segment Size)` 라고 부른다.

- 이는 IP헤더와 TCP 헤더를 모두 포함한 크기인 MTU와는 차이가 있다.

세그먼트의 주요 구성요소는 다음과 같다.

- 송신지 포트와 수신지 포트: 송신지와 수신지의 어플리케이션으로 이어지기 위한 정보

- 순서번호: 송 수신되는 세그먼트의 올바른 순서를 보장하기 위한 순서번호, 제어비트에 SYN이 1로 설정 되어 있다면 연결수립 목적의 초기 할당으로 무작위 값이 적힌다.

- 확인 응답번호: 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음에 받기를 원하는 순서번호가 명시됨, 제어비트에 ACK가 켜져있어야 함

- 제어비트: 현재 세그먼트가 어떤 종류의 세그먼트인지에 대한 플래그 비트

- 윈도우: 수신 윈도우의 크기가 명시됨. 수신 윈도우는 한번에 받는 데이터 양을 의미함

특히나 여기서 `제어비트`와 `순서번호`, `확인 응답번호`가 중요하다.

`제어비트`는 어떤 세그먼트인지 나타냄으로서 `SYN`, `ACK`, `FIN`를 주요 연결, 해제 목적으로 사용한다.

`순서번호`와 `확인 응답번호`는 쌍으로서 신뢰성을 보장하기위한 비트이다.

`순서번호`의 경우 초기 연결 수립을 위한 `SYN`비트를 보낼 때에는 무작위 숫자가 배정된다. 

그리고 다음번호는 `초기 순서번호 + 송신한 데이터의 양`만큼 계산된다.

`확인 응답번호`의 경우에는 세그먼트에 대한 응답으로서 `다음에 받기를 원하는 순서번호를 확인 응답번호로서 명시`하여 전달한다.

```
예를들어 호스트 A가 B와 연결을 수립할때 초기 순서번호는 무작위로 선정된다.

그리고 전송해야할 세그먼트의 길이가 1900바이트고 A의 MSS는 500인 경우 

500 | 500 | 500 | 400 을 전송해야 한다.

이 때 초기 연결때 사용된 순서 번호가 현재 100이라면 500짜리를 보내고나서 호스트 A의 순서번호는 600으로 시작된다.
```

### TCP 연결 수립과 종료, TCP State

TCP의 연결은 `3-Way-HandShake`로 작동한다.

연결 요청을 보내는 호스트를 `액티브 오픈`이라고 하고, 연결 요청을 받는 입장에서는 `패시브 오픈`이라고 한다.

TCP 연결에서 사용되는 상태는 `SYN-SENT`, `SYN-RECEIVED`, `ESTABLISHED`가 있다.

물론 그 전 아무런 연결이 없는 상태에서도 TCP상태를 의미하는 것으로 `CLOSED`와 `LISTEN`이 있다.

이는 둘다 연결 안됨을 나타내는 것이지만, `CLOSED`는 주로 액티브 오픈 대상에게 붙는 상태이고 `LISTEN`은 `SYN`신호를 기다리는 패시브 오픈 상태이다.

연결 수립 순서는 다음과 같다.

1. 요청자(액티브 오픈)가 요청 받는자(패시브 오픈)에게 SYN 비트를 보낸다.

    - 이 때 요청자는 자신의 요청을 받았다는 ACK와 상대측도 본인에게 요청하는 SYN를 받아야한다.

    -  즉, SYN + ACK를 받기를 대기하는 상태로서 자기가 먼저 SYN을 보냈다는 `SYN-SENT` 상태가 된다.

2. 요청 받는자(패시브 오픈)이 요청자(액티브 오픈)에게 ACK와 함께 SYN를 보낸다.

    - 이 때 요청자는 마지막 ACK을 기다리며, 본인이 SYN을 받았다는 `SYN-RECEIVED` 상태가 된다.

3. 요청자(액티브 오픈)는 ACK를 보내고 `ESTABLISHED` 상태에 진입한다.

    - 요청 받는자도 ACK를 받고나서 `SYN-RECEIVED` -> `ESTABLISHED` 상태로 진입하고 데이터를 송수신한다.

결론
```
SYN(호스트A: SYN-SENT, 호스트B: LISTEN) -> ACK SYN(호스트A: SYN-SENT, 호스트B: LISTEN -> SYN-RECEVIED) -> ACK(호스트A: SYN-SENT -> ESTABLISHED, 호스트B: ACK받고나서 SYN-RECEIVED -> ESTABLISHED)
```

종료 수립 순서는 `4-Way-HandShake` 라고 부르고 제어비트가 `FIN` 세그먼트를 보냄으로서 시작한다.

종료 수립을 할 때에는 종료요청을 보내는 쪽이 `액티브 클로즈`이고, 종료요청을 받아서 처리하는쪽이 `패시브 클로즈` 라고 한다.

종료 수립 순서는 다음과 같다.

1. 요청자(액티브 클로즈)가 요청 받는자(패시브 클로즈)에게 `FIN` 세그먼트를 보낸다.

    - 이 때 요청자는 보내고난 후 `FIN-WAIT-1` 상태에 진입하여, 자신의 요청에 대한 ACK를 받기를 기다린다.

2. 요청 받는자(패시브 클로즈)는 요청자(액티브 클로즈)에게 `ACK`를 보낸다.

    - 이 때 요청 받는자(패시브 클로즈)는 `CLOSE-WAIT`상태에 진입한다.

        - 이 `CLOSE-WAIT`는 본인의 종료준비라고 생각하면 된다.

    - `ACK`를 받은 요청자(액티브 클로즈)는 이번에는 상대의 `FIN` 세그먼트를 기다리는 `FIN-WAIT-2` 상태에 진입한다.

3. 요청 받는자(패시브 클로즈)는 자신의 종료를 알리는 `FIN` 세그먼트를 요청자(액티브 클로즈) 에게 보낸다.

    - 이 때 요청 받는자(패시브 클로즈)는 마지막 본인 `FIN`의 `ACK`를 기다린다는 `LAST ACK`상태에 진입한다.

4. 요청자(액티브 클로즈)는 `FIN`에 대한 `ACK`를 보내고 `TIME-WAIT`상태에 진입후 일정시간 후에 `CLOSED`상태에 진입한다.

    - `ACK`를 받은 요청 받는자(패시브 클로즈)는 곧바로 `CLOSED`상태에 진입한다.

결론: 
```
초기 두 호스트는 ESTABLISHED 상태

여기서 A -> B에게 FIN을 보내면

A: ESTABLISHED -> FIN-WAIT-1이 되고 ACK를 기다린다.

FIN을 받은 B는 ACK를 보내고 ESTABLISHED -> CLOSE-WAIT 상태에 들어간다.

B: ESTABLISHED -> CLOSE-WAIT

ACK를 받은 A는 B의 FIN을 기다리는 FIN-WAIT-2 상태에 들어간다.

A: FIN-WAIT-1 -> FIN-WAIT-2

B의 CLOSE-WAIT 후 FIN 세그먼트를 A로 보내고 CLOSE-WAIT -> LAST ACK 상태에 진입한다.

B: CLOSE-WAIT -> LAST ACK

A는 FIN을 받았으니까 ACK를 보내고 FIN-WAIT-2 -> TIME-WAIT 상태로 진입한다.

A: FIN-WAIT-2 -> TIME-WAIT

본인의 전송에 대한 ACK를 받은 B는 LAST ACK -> CLOSED 상태로 진입한다.

B: LAST ACK -> CLOSED

일정 시간 후, A도 TIME-WAIT -> CLOSED 상태로 진입힌다.

A: TIME-WAIT -> CLOSED
```

여기서 `TIME-WAIT`이 존재하는 이유는 상대 호스트가 받아야 할 마지막 `ACK`를 못받아서 재전송해야할 수도 있고, 

종료후에 대기시간이 없으면 서로 다른 연결의 패킷들이 혼란이 야기될 수 있다.

### 헷갈렸던 부분: 그럼 연결이 확립된 후에는 제어비트가 어떻게되는가?

<a href="https://datatracker.ietf.org/doc/html/rfc9293#section-3.1-6.8.2">IETF TCP: Acknowledgment Number</a>

제어비트는 SYN를 위한 비트, ACK를 위한 비트, FIN을 위한 비트이 있다고 위에서 알 수 있다. 

초기 연결수립을 위해 제어비트에 SYN에 대하여 1을 설정하고, 무작위 초기 순서번호를 부여한다.

그렇게 해서 SYN, ACK를 주고받거니 한뒤, `ESTABLISHED가 되면 ACK플래그가 1인 상태로 서로 데이터를 주고받는다.`

이 때 `순서번호`는 처음 연결을 수립하기위한 무작위 순서번호로 부터 송신한 데이터길이 만큼 늘어난다.

### 둘이서 동시에 종료신호를 보낸경우: CLOSING

<a href="https://datatracker.ietf.org/doc/html/rfc9293#section-3.6-4.6.2">IETF TCP: Both users close simultaneously</a>

종료의 방식 중 하나라고 한다.

둘이서 동시에 종료신호를 보낸경우 둘다 서로의 ACK를 받고나서 바로 종료한다.

### UDP

UDP는 TCP에서 빠름을 중시하기 위해 연결 수립과정 및 신뢰성 보장기능을 모두 뺀 방식이다.

그래서 송신지 포트 수신지포트 길이, 체크섬 밖에 없다.

흔히 체크섬 때문에 "신뢰성이나 안정성은 보장되는거 아님?" 일 수 있으나, 재전송 그런기능의 목적이 아닌 단순히 수신지에서 훼손되었는지만 체크하므로 관련이 없다.

